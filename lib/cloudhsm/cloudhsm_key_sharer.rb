require 'greenletters'

# In prod this script is run through the cloudhsm rake task which will run on a RamDisk
# Grants access to the key generated by cloudhsm_key_generator to the idp user
# Uses the saml key label and cached output from the generator (credentials/key handle)
# Outputs to file saml_<timestamp>.shr (a transcript of the cloudhsm interaction)

class CloudhsmKeySharer
  CLOUDHSM_MGMT_UTIL = \
    '/opt/cloudhsm/bin/cloudhsm_mgmt_util /opt/cloudhsm/etc/cloudhsm_mgmt_util.cfg'.freeze

  def initialize(saml_label)
    @saml_label = saml_label
    @username, @password, @key_handle, @idp_username = read_credentials_and_private_key_handle
    @kmu = run_cloudhsm_mgmt_util
    wait_for_command_to_finish
    enable_encrypted
  end

  def share_saml_key
    login_to_hsm
    idp_user_id = idp_user_id_from_list_users
    raise "User #{@idp_username} not found" unless idp_user_id
    share_key(@key_handle, idp_user_id)
    exit_hsm
  end

  private

  def read_credentials_and_private_key_handle
    File.read("#{@saml_label}.scr").to_s.chomp.split(':')
  end

  def run_cloudhsm_mgmt_util
    output = File.open("#{@saml_label}.shr", 'w')
    kmu = Greenletters::Process.new(CLOUDHSM_MGMT_UTIL, transcript: output)
    kmu.start!
    kmu
  end

  def enable_encrypted
    @kmu << "enable_e2e\n"
    @kmu.wait_for(:output, /E2E enabled/)
    wait_for_command_to_finish
  end

  def idp_user_id_from_list_users
    @kmu << "listUsers\n"
    user_id = nil
    @kmu.wait_for(:output, /\d+\s+CU\s+#{@idp_username}/) do |_process, matching|
      user_id = matching.matched.split[0]
    end
    wait_for_command_to_finish
    user_id
  end

  def share_key(key_handle, user_id)
    @kmu << "shareKey #{key_handle} #{user_id} 1\n"
    @kmu.wait_for(:output, %r{Do you want to continue\(y/n\)\?})
    @kmu << "y\n"
    @kmu.wait_for(:output, /success on server/)
    wait_for_command_to_finish
  end

  def login_to_hsm
    @kmu << "loginHSM CU #{@username} #{@password}\n"
    @kmu.wait_for(:output, /loginHSM success/)
    wait_for_command_to_finish
  end

  def exit_hsm
    @kmu << "quit\n"
    Kernel.puts "Key shared with the idp user successfully\n" \
                "Transcript written to '#{@saml_label}.shr'.\n"
  end

  def wait_for_command_to_finish
    @kmu.wait_for(:output, /aws-cloudhsm>/)
  end
end

CloudhsmKeySharer.new(ARGV[0]).share_saml_key if $PROGRAM_NAME == __FILE__

# cat saml_20180721031604.scr
# gen_user:password:1234:idp_user

# /opt/cloudhsm/bin/cloudhsm_mgmt_util /opt/cloudhsm/etc/cloudhsm_mgmt_util.cfg

# Connecting to the server(s), it may take time
# depending on the server(s) load, please wait...
# Connecting to server '127.0.0.1': hostname '127.0.0.1', port 2225...
# Connected to server '127.0.0.1': hostname '127.0.0.1', port 2225.

# aws-cloudhsm>enable_e2e
# Server 0(127.0.0.1) is in e2e mode now...

# aws-cloudhsm>loginHSM CU idp_generator password
# loginHSM success on server 0(127.0.0.1)

# aws-cloudhsm>listUsers
# Users on server 0(127.0.0.1):
# Number of users found:5

# User Id  User Type  User Name  MofnPubKey  LoginFailureCnt  2FA
# 1        CO         admin      NO          0                NO
# 2        AU         app_user   NO          0                NO
# 3        AU         jane_doe   NO          0                NO
# 4        CU         idp_user   NO          0                NO
# 5        CU         gen_user   NO          0                NO

# aws-cloudhsm>shareKey 1234 4 1
# *************************CAUTION********************************
# This is a CRITICAL operation, should be done on all nodes in the
# cluster. Cav server does NOT synchronize these changes with the
# nodes on which this operation is not executed or failed, please
# ensure this operation is executed on all nodes in the cluster.
# ****************************************************************

# Do you want to continue(y/n)?y
# shareKey success on server 0(127.0.0.1)

# aws-cloudhsm>quit
# disconnecting from servers, please wait...
